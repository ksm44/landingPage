/*У некоторых чисел есть забавные свойства.
Например:
89 -> 8¹ + 9² = 89 * 1
695 -> 6² + 9³ + 5⁴ = 1390 = 695 * 2
46288 -> 4³ + 6⁴ + 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
Дано положительное целое число n, записанное как abcd ... (a, b, c, d ... цифры)
и положительное целое число p. мы хотим найти положительное целое число k, если
оно существует, например, сумма цифр n, взятых в последовательные степени p,
равна k * n. Другими словами: Существует ли целое число k, например:
(a ^ p + b ^ (p + 1) + c ^ (p + 2) + d ^ (p + 3) + ...) = n * k
Если это так, мы вернем k, если не вернем -1.
Примечание : n и p всегда будут указываться как строго положительные целые числа.
digPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1
digPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k
digPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2
digPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51 */

let n = 46288;
let p = 3;


function digPow(n, p){
  let k;
  let arr = [];
  let result = 0;
  n = "" + n;
  arr = n.split("");
  for (let i = 0; i < arr.length; i++) {
    result += arr[i] ** (p + i);
  }

  if (!(result%n)) {
    k = result / n;
  }  else k = -1;
  return k;
}

console.clear();
console.log(digPow(n, p));


